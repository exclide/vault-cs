## Классификация
OLTP - online transaction procesing, небольшие транзакции, короткое время жизни запросов (Postgres, Redis). Строковые
OLAP - online analytical processing, агрегирует данные с многих таблиц (Clickhouse). Колоночные. Для аналитики

Резидентные (в памяти) - MemCached, Redis, KeyDb
Дисковые - Postgresql

Строковые - подходят когда данные должны читаться все целиком. Накладные расходы на чтение всех столбцов строки
Колоночные - подходят для аналитики, можем агрегировать удобно конкретные колонки. Больше возможностей сжатия, т.к. в одной колонки одни типы

## B-дерево
![[Pasted image 20240426093639.png]]

Вершины - вместо одного значения бинарного N значений
Дети - вместо двух бинарного N+1 под каждую перегородку, значения разбиваются по отрезкам: самое левое от минус бесконечности до значения, потом от значения до следующего, наконец от последнего до плюс бесконечности

В листьях B-дерево всегда связный список из указетелей на строки, таким образом удобно можем брать множество строк в запрос.

## Уровни изоляции транзакций
Read uncommitted - данные могут быть прочитаны до коммита транзакции
Read committed - данные могут быть прочитаны только после коммита транзакции
Repeteable read - как и read committed, только видим изменения до коммита внутри одной транзакции
Serializable - блокирует каждую строку транзакции

## ACID транзакций
Atomicity - атомарность транзакции, результат либо запись всего commit, либо ничего rollback
Consistency - согласованность данных. Свойство приложения, т.е. зависит от нас. Транзакция переводит базу из одного согласованного состояния в другое согласованное. (например UnitOfWork)
Isolation - изолированность транзакций. Транзакции работающие с одинаковыми строками изолированы друг от друга (блокировки или версионирования)
Durability - после коммита изменения должны быть фиксированы на диске


## Компоненты Postgresql
![[Pasted image 20240426161700.png]]

## Побочные эффекты конкуретных транзакций
**Lost update** - потерянный апдейт, самый опасный эффект изоляции конкурентных транзакций. Когда приходит один запрос, берет строку наприер, что-то делает с ней, в это время приходит второй берет эту же строку и начинает чет делать, первый при этом завершается, а потом завершается второй и перезаписывает данные. Возникает, когда вообще не используем никаких транзакций. Фиксится транзакцией с минимальным уровнем изоляции - Read Uncommited (читай НЕКОМИТЕД)

**Dirty read** - когда запрос читает грязные данные, которые еще не закомичены параллельной транзакцией. Фиксится уровнем изоляции транзакции - Read Commited (читай только КОМИТЕД)

**Non-repeatable-read** - одинаковый запрос в одной транзакции может вернуть разные данные. Фиксится уровнем Repeatable Read (читаем одно и то же). Достигается блокировками строк. То есть пока одна транза работает со строкой, не может прийти другая и начать с ней что-то делать

**Phantom reads** - похож на non-repeatable-read, но второй запрос может не коммитнуть данные, получаем что первый получить фантомные, не существующие данные. Также блокировки. Фиксится уровнем Serializable - последовательное упорядочивание запросов.

**Разница уровней Repeatable Read и Serializable,** что Repeatable Read хотя и блокирует строки, но другие клиенты еще могут вставлять строки, соответствующие условиям поиска в первой транзакции. С Serializable они заблокируются в том числе