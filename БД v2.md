## Типы
Реляционные БД (SQL) - таблицы, строгая схема, типы атрибутов, отношения с другими таблицами по FK->PK  
Нереляционные (NoSQL) -   
InMemory - кэши, используем чтобы ускорить чтение часто используемых данных (Redis, memcached)  
Колоночные - можем достать конкретные столбцы, не нужно читать все строки (ClickHouse)   
Графовые - (GraphQL)


## Классификация
OLTP - online transaction procesing, небольшие транзакции, короткое время жизни запросов (Postgres, Redis). Строковые
OLAP - online analytical processing, агрегирует данные с многих таблиц (Clickhouse). Колоночные. Для аналитики

Резидентные (в памяти) - MemCached, Redis, KeyDb
Дисковые - Postgresql

Строковые - подходят когда данные должны читаться все целиком. Накладные расходы на чтение всех столбцов строки
Колоночные - подходят для аналитики, можем агрегировать удобно конкретные колонки. Больше возможностей сжатия, т.к. в одной колонки одни типы

## B-дерево
![[Pasted image 20240426093639.png]]

Вершины - вместо одного значения бинарного N значений
Дети - вместо двух бинарного N+1 под каждую перегородку, значения разбиваются по отрезкам: самое левое от минус бесконечности до значения, потом от значения до следующего, наконец от последнего до плюс бесконечности

В листьях B-дерево всегда связный список из указетелей на строки, таким образом удобно можем брать множество строк в запрос.

## Уровни изоляции транзакций
Read uncommitted - данные могут быть прочитаны до коммита транзакции
Read committed - данные могут быть прочитаны только после коммита транзакции
Repeteable read - как и read committed, только видим изменения до коммита внутри одной транзакции
Serializable - блокирует каждую строку транзакции

## ACID транзакций
Atomicity - атомарность транзакции, результат либо запись всего commit, либо ничего rollback
Consistency - согласованность данных. Свойство приложения, т.е. зависит от нас. Транзакция переводит базу из одного согласованного состояния в другое согласованное. (например UnitOfWork)
Isolation - изолированность транзакций. Транзакции работающие с одинаковыми строками изолированы друг от друга (блокировки или версионирования)
Durability - после коммита изменения должны быть фиксированы на диске


## Компоненты Postgresql
![[Pasted image 20240426161700.png]]

## Побочные эффекты конкуретных транзакций
**Lost update** - потерянный апдейт, самый опасный эффект изоляции конкурентных транзакций. Когда приходит один запрос, берет строку наприер, что-то делает с ней, в это время приходит второй берет эту же строку и начинает чет делать, первый при этом завершается, а потом завершается второй и перезаписывает данные. Возникает, когда вообще не используем никаких транзакций. Фиксится транзакцией с минимальным уровнем изоляции - Read Uncommited (читай НЕКОМИТЕД)

**Dirty read** - когда запрос читает грязные данные, которые еще не закомичены параллельной транзакцией. Фиксится уровнем изоляции транзакции - Read Commited (читай только КОМИТЕД)

**Non-repeatable-read** - одинаковый запрос в одной транзакции может вернуть разные данные. Фиксится уровнем Repeatable Read (читаем одно и то же). Достигается блокировками строк. То есть пока одна транза работает со строкой, не может прийти другая и начать с ней что-то делать

**Phantom reads** - похож на non-repeatable-read, но второй запрос может не коммитнуть данные, получаем что первый получить фантомные, не существующие данные. Также блокировки. Фиксится уровнем Serializable - последовательное упорядочивание запросов.

**Разница уровней Repeatable Read и Serializable,** что Repeatable Read хотя и блокирует строки, но другие клиенты еще могут вставлять строки, соответствующие условиям поиска в первой транзакции. С Serializable они заблокируются в том числе

## Планировщик запросов
**Задача планировщика** - создать наиболее оптимальный план выполнения запроса. План - какие таблицы будут задействованы, какой тип поиска будем использовать в таблице: seq, index scan, какой тип соединения таблиц будет использовать: nested loop, hash join, merge join

#### Операции выборки
1. Seq scan - последовательно достаем строки базы - O(n)
2. Index scan - делаем поиск по индексу, из него идем по строкам базы - O(1) hash, O(logn) B-Tree
3. Index only scan - делаем поиск по индексу, в самом индексе есть все данные, в случае плотноо индекса - O(1), O(logn)
4. Bitmap scan - выбираем по индексу нужные строки, потом последовательно достаем их из базы

#### Операции соединения
1. Nested loop - берем каждую строку с каждой - O(n^2)
2. Merge join - каждую таблицу сортируем по join атрибуту и сливаем два отсортированных списка. При этом сортировка может быть как явной отдельной, так и с использованием индекса по ключу слияния - O(nlogn)
3. Hash join - сканируем правую таблицу и составляем мапу, где ключом будет атрибут слияния, а значением - сама строка в бд. Далее сканируем левую таблицу и по атрибуту слияния находим соответствующую строку в правой таблице - O(n), O(n^2). Оверхед на построение хэштаблицы, в худшем, если планировщик решит использовать Nested


## Блокировки
Предикатные - используется в транзакциях с уровнями Serializable и Repeatable read, по сути не блокировка, то есть мы не ждем конкурентной транзакции, а падаем с ошибкой - а значит на клиенте нужно уметь ловить и корректно обрабатывать такие ошибки.  
По строкам  
По таблицам  
Вся бд

## Режимы блокировок
![[Pasted image 20240506131012.png]]

## Нормальные формы
N НФ - находится в N-1 НФ для всех

Функциональная зависимость - множество атрибутов A функционально зависит от множества атрибутов B, когда каждое значение множества A связано ровно с одним значением множества B. 

1НФ - скалярные, атомарные, неделимые значения, т.е. нету списков значений - решается декомпозицией на доп таблицу с ссылкой FK на текущую  
2НФ - каждый неключевой атрибут функционально полно зависит от ключа. Функционально полная зависимость означает, что если потенциальный ключ является составным, то атрибут зависит от всего ключа в целом, а не от его частей. Если потенциальный ключ является простым, то есть состоит из единственного атрибута, то любая функциональная зависимость от него является неприводимой (полной).
3НФ - ни один неключевой атрибут не находится в транзитивной функциональной зависимости от потенциального ключа. 

![[Pasted image 20240506200508.png]]

Каждый сотрудник относится исключительно к одному отделу; каждый отдел имеет единственный телефон. Атрибут Сотрудник является первичным ключом. Личных телефонов у сотрудников нет, и телефон сотрудника зависит исключительно от отдела.

В примере существуют следующие функциональные зависимости: Сотрудник → Отдел, Отдел → Телефон, Сотрудник → Телефон.

Переменная отношения R1 находится во второй нормальной форме, поскольку каждый атрибут имеет неприводимую функциональную зависимость от потенциального ключа Сотрудник.

Зависимость Сотрудник → Телефон является транзитивной, следовательно, отношение не находится в третьей нормальной форме.

В результате разделения R1 получаются две переменные отношения, находящиеся в 3NF:
![[Pasted image 20240506200547.png]]