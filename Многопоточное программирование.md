,### Процесс
Виртуальное адресное пространство, код и данные программы, открытые файлы, сокеты, итд.

### Поток (thread - preemtive multitasking)
Контекст исполнения внутри процессора, набор инструкция процессора, свой стек для каждого потока, общее виртуальное адресное пространство (общий heap-space). Управляется из kernel-space, вытесняющая многозадачность - ОС сама решает, какой поток поставить на выполнение процессора.

### Волокно (fiber - cooperative multitasking)
Легковесный поток выполнения. Множество волокон в одном потоке. Управляется из user-space, поэтому невытесняющая или кооперативная многозадачность - код сам решает, когда отправить волокно в ожидание, например, с помощью вызова Yield.

### Корутина (cooperative multitasking)
Функция, выполнение которой можно поставить на паузу. Использует thread pool, переключается между потоками выполнения, тем самым обеспечивая конкурентность.

Ассиметричная - поток использует Yield(), чтобы передать управление планировщику, который в свою очередь передаст управление следующему в очереди фрейму  
Симметричная - Yield() выбирает сразу фрейм, которому нужно передать управление

### Параллелизм
Про фактическое одновременное выполнение кода. Для этого нужно как минимум 2 ядра, т.к. один юнит процессора может исполнять одновременно только одну инструкцию.
### Конкурентность  
Про видимое одновременное выполнение кода, т.е. иллюзия одновременного выполнения. Например, на одноядерном процессоре запущена операционная система, в ней браузер, во вкладках 10 видео, а еще открыт ТГ, и IDE - тут благодаря прерываниям и следующей за ними сменой контеста процессора, создается ощущение, что все происходит одновременно. В контексте Boost.Asio это значит, что чтение/запись, например в сокет, не блокируется, ожидая возврата из функции, а выполняется асинхронно, но в какой-то другой момент времени будет вызван обработчик завершения асинхронного вызова (handler), за это отвечает io_context, thread_pool/executor. Это Reactor pattern. То есть даже на одном процессоре мы можем добиться видимого одновременного исполнения, при этом если у нас io_context > 1, то будет и параллельное выполнение, но тогда надо уже думать о синхронизации данных, чтобы избежать гонок

### Критическая секция
Защищенный фрагмент кода, который должен выполняться единовременно только на одном потоке.

### Mutex
Бинарный семафор, в основе которого использование атомарной инструкции процессора test_and_set/exchange/fetch_add - которая одновременно читает и пишет значение. Нужен для защиты критических секций.

### Spinlock
Мютекс, который вместо того, чтобы уходить в ожидание через системный вызов, крутится в бесконечном цикле  
```cpp
std::atomic_flag flag = ATOMIC_FLAG_INIT;
while(flag.test_and_set()); //атомарно читаем и если флаг false, то есть никто не зашел в секцию, ставим флаг в true
```

### Semaphore
Похож на мютекс, но вместо состояний занято/свободно предоставляет уровень занятости/нагруженности. Есть две похожие на lock, unlock мютекса операции. Первая инкрементирует атомарный счетчик, вторая атомарно проверяет счетчик и декрементирует его. Блокируемся только если счетчик равен нулю - тогда наш ресурс полностью занят.

### Deadlock
Например, когда для выполнения секции кода, потоку необходимо захватить сразу два мютекса, приходит первый поток захватывает m1, второй в это время захватывает m2, теперь оба находятся в бесконечном ожидании мютексов.

### Livelock
Более легкая форма дедлока, потоки не блокируются окончательно, но постоянно сменяют друг друга так, что отсутствует прогресс

### Data race (гонка)
Когда у нас есть два и более потока, при этом хотя бы один из них на запись.

### Голодание
Когда какой-либо поток никогда не попадает в критическую секцию.

### Conditional variable
Примитив синхронизации, позволяющий реагировать одному потоку на событие произошедшее в другом. Например, вместо бесконечного цикла, захватывающего и отпускающего мютекс на очередь, чтобы ее прочитать, создадим conditional_variable, который будет реагировать на непустую очередь, а в другом потоке будет с помощью notify_one(), notify_all() сообщать и записи в очередь. В первом потоке, если наше условие еще не выполнено, мы будем отпускать мютекс и уходить в сон, периодически будем просыпаться, брать мютекс и проверять условие.  

```cpp
#include "bits/stdc++.h"  
  
std::queue<int> q;  
std::mutex m;  
std::vector<int> v = {1,2,3,4,5,6,7,8,9};  
std::condition_variable cv;  
  
void write_queue() {  
	std::unique_lock lock(m);  
	for (int i : v) q.push(i);  
	cv.notify_one();  
}  

int main() {  
	std::thread t1(write_queue);  
	std::unique_lock lock(m);  
	while (q.empty()) cv.wait(lock);  
	
	while (!q.empty()) {  
		std::cout << q.front();  
		q.pop();  
	}  
  
	t1.join();  
	return 0;  
}
```


## Модели памяти

```js
thread P:
x = 1
r1 = y

thread Q:
y = 1
r2 = x
```

Что будет в r1, r2? Может быть в том числе (0, 0), т.к. строки не исполняются последовательно из-за оптимизаций компилятора/процессора. При записи в переменную, процессор сначала пишет в буффер (write buffer), и лишь потом в память. При этом, в одном потоке нам гарантируется видимость последовательного исполнения, т.е. если мы попытаемся прочитать переменную, в которую до этого записали, процессор обязан выдать обновленное значение. Но в разных потоках нет видимости последовательного выполнения.

#### Модель happens before (произошло до)
На операциях определен частичный порядок e->f (e произошло до f)

Две операции e и f параллельны, если и НЕ e->f и НЕ f->e

Операция (сложная) состоит из двух событий (простых):  
inv(e) - вызов операции  
res(e) - ответ на операцию (результат)  

e->f когда res(e) < inv(f) (результат e произошел до вызова f)

#### Система - набор всех возможных исполнений программы

#### Последовательное исполнение
Когда все операции линейно-упорядочены отношением "happens before". То есть нету параллельных операций.

