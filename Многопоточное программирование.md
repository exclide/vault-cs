### Процесс
Виртуальное адресное пространство, код и данные программы, открытые файлы, сокеты, итд.

### Поток (thread - preemtive multitasking)
Поток выполнения команды, набор инструкция процессора, свой стек для каждого потока, общее виртуальное адресное пространство (общий heap-space). Управляется из kernel-space, вытесняющая многозадачность - ОС сама решает, какой поток поставить на выполнение процессора.

### Волокно (fiber - cooperative multitasking)
Легковесный поток выполнения. Множество волокон в одном потоке. Управляется из user-space, поэтому невытесняющая или кооперативная многозадачность - код сам решает, когда отправить волокно в ожидание.

### Параллелизм
Про фактическое одновременное выполнение кода. Для этого нужно как минимум 2 ядра, т.к. один юнит процессора может исполнять одновременно только одну инструкцию.
### Конкурентность  
Про видимое одновременное выполнение кода, т.е. иллюзия одновременного выполнения. Например, на одноядерном процессоре запущена операционная система, в ней браузер, во вкладках 10 видео, а еще открыт ТГ, и IDE - тут благодаря прерываниям и следующей за ними сменой контеста процессора, создается ощущение, что все происходит одновременно. В контексте Boost.Asio это значит, что чтение/запись, например в сокет, не блокируется, ожидая возврата из функции, а выполняется асинхронно, но в какой-то другой момент времени будет вызван обработчик завершения асинхронного вызова (handler), за это отвечает io_context, thread_pool/executor. Это Reactor pattern. То есть даже на одном процессоре мы можем добиться видимого одновременного исполнения, при этом если у нас io_context > 1, то будет и параллельное выполнение, но тогда надо уже думать о синхронизации данных, чтобы избежать гонок

### Критическая секция
Защищенный фрагмент кода, который должен выполняться единовременно только на одном потоке.

### Mutex
Бинарный семафор, в основе которого использование атомарной инструкции процессора test_and_set/exchange/fetch_add - которая одновременно читает и пишет значение. Нужен для защиты критических секций.

### Spinlock
Мютекс, который вместо того, чтобы уходить в ожидание через системный вызов, крутится в бесконечном цикле  
```cpp
std::atomic_flag flag = ATOMIC_FLAG_INIT;
while(flag.test_and_set()); //атомарно читаем и если флаг false, то есть никто не зашел в секцию, ставим флаг в true
```

### Semaphore
Похож на мютекс, но 

### Deadlock
Например, когда для выполнения секции кода, потоку необходимо захватить сразу два мютекса, приходит первый поток захватывает m1, второй в это время захватывает m2, теперь оба находятся в бесконечном ожидании мютексов.

### Livelock
Более легкая форма дедлока, потоки не блокируются окончательно, но постоянно сменяют друг друга так, что отсутствует прогресс

### Data race (гонка)
Когда у нас есть два и более потока, при этом хотя бы один из них на запись.

### Голодание
Когда какой-либо поток никогда не попадает в критическую секцию.
