### Характеристики языка
Мультипарадигменный (процедурный и ООП)  
Эффективный  
Низкоуровневый  
Компилируемый  
Статически типизрованный  

### Как компилируются программы
1. Препроцессор обрабатывает директивы с #
2. Компилруются только .cpp файлы, каждый в соответствующий объектный .o/.obj файл
3. Линковщик (компоновщик) берет объектные файлы и объединяет в исполняемый - на этом этапе подстановка адресов функций в места их вызова

### Операторы new/delete vs malloc/free
New/delete вызывают конструктор/деструктор объектов, malloc/free объекты остаются неинициализированными. Для new[] массивов создаются с конструктором по умолчанию

### Placement new
Если память для объекта уже выделена, можно сконструировать объект по этой памяти с placement new - оператор вызывает конструктор по переданному адресу
```cpp
T* obj = new (ptr) T(args);
```

### Полиморфизм
Статический - перегрузка или переопределение функций на этапе компиляции  
Динамический - переопределение функций в рантайме (virtual функции класса)

### Виртуальный деструктор
Нужен, чтобы корректно удалять ресурсы производного класса при работе с ними через указатель на базовый класс.

### Правило пяти (rule of five)
https://en.cppreference.com/w/cpp/language/rule_of_three

Если реализовали одно из пяти перечисленных, то нужно реализовать и все остальные:
1. Деструктор - ~T()
2. Copy constructor - T(const T& other);
3. Copy assignment operator= - T& operator=(const T& other);
4. Move constructor - T(T&& other);
5. Move assignment operator= - T& operator=(T&& other);

Потому что необходимость реализации одного из этого подразумевает наличии управляемого ресурса, для которого нужна нетривиальная логика копирования/перемещения и удаления. Кроме того реализация деструктора, копи конструктора и копи оператора присваивания удаляет неявную реализую мув конструктора/оператора.

### Абстрактные классы, чистые виртуальные методы
Классы, в которых объялвен чистый виртуальный метод (метод без реализации), поэтому нельзя создать экземпляр класса
```cpp
struct Person {
	virtual void name() const = 0;
}
```

### Таблица виртуальных методов
Virtual method table - добавляется в начало памяти любого объекта с виртуальными методы, по сути массив из указателей на методы. VTable одинаков для всех объектов одного класса. При вызове функции, вместо замены ее вызова на адрес функции при компиляции, происходит замена на номер функции в таблице (массиве) виртуальных методов.

### RAII - Resource Acquisition Is Initialization
RAII - принцип, правило, согласно которому ресурсами должны управлять специальные классы-обертки, в конструкторе которым передается ресурс, а в деструкторе они его освобождают. Согласно этому принципу "сырые" new, delete, mutex. lock/unlock не должны использоваться. Например shared_ptr, unique_ptr, lock_guard, unique_lock, scoped_lock, vector, string итд

### Ключевое слово inline
Вместо вызова функции по адресу, компилятор попытается подставить (встроить) тело функции в место ее вызова.
Inline функции нужно определять в заголовочных файлах, т.к. компилятор должен видеть тело inline функции, чтобы его встроить.

### Ключевое слово friend
Если в классе функция или другой класс объявлены как friend (дружественный), то эта функция или класс имеет полный доступ к классу, ко всем приватным полям и методам.

### Специализация шаблонов
Полная
```cpp
template<>
class Foo<int>{}
```

Частичная
```cpp
template<class T>
class Foo<T*>{}
```

### Касты (преобразования типов)
**c-style cast** - const_cast -> static_cast -> reinterprest_cast  

**static_cast** - каст между связными типами, все стандарнтые и неявные, все касты от производных классов к базовым (upcast) и наоборот (downcast). Каст проверяется на этапе компиляции, поэтому не очень подходит для преобразования указателей на классы с виртуальными функциями  

**const_cast** - снятие/добавление константности. Для снятия константности, т.к. добавление происходит неявно. Пример нормального использования - реализация доступа по индексу для константных и не константных коллекций.  

**reinterpret_cast** - низкоуровневый, несвязные типы.

**dynamic_cast** - касты между типами связанными наследованием, с проверкой корректности каста в рантайме. Можно использовать также, чтобы понять что действительно находится в указателе на базовый класс.
```cpp
Base* b;
Derived* d;
d = dynamic_cast<Derived*>(b); //если в b не derived, вернет nullptr
```

### Семантика перемещения, move semantic (lvalue, rvalue), (std::move, std::forward)
Зачем - позволяет избежать копирования во время конструирования и присваиния, когда оно не нужно.
Перемещающие конструкторы и операторы присваивания "крадут" ресурс у другого объекта, оставляя его в согласованном состоянии.

**lvalue** - можно присвоить, по левую сторону  
**rvalue** - временное значение, по правую сторону

**Универсальная ссылка - шаблонная функция** 
```cpp
template<class T>
void func(T&& arg);
```

**std::move** - каст в rvalue  
**std::forward** - каст в lvalue, если получили аргументом lvalue, в rvalue, если получили rvalue.

Реализация std::make_unique через perfect forwarding и variadic templates
```cpp
template<class T, class... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
	return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

```

### Множественное наследование (diamond problem)
![](/data/diamond_problem.jpg)

В первом случае без virtual - дубликаты базового класса и неопределенность при попытке изменить поля или вызывать методы базового класса, т.к. они в двух экземплярах. Можно исправить явным указанием класса Base::(). Но лучше использовать virtual наследование, чтобы был всего один экземпляр базового класса.


### Итераторы
**Random access (произвольного доступа)** - самый сильный, поддерживает арифметику, ++, --, >, < (vector, deque, array)  
**Bidirectional (двунаправленный)** - поддерживает ++, -- (list, set, map)  
**Forward (однонаправленный)** - поддерживает ++ (forward_list, unordered_set, unordered_map)

Для пополнения контейнеров итераторы:  
back_inserter, front_inserter, inserter

Функции для работы с итераторами:  
advance(it, size_t n) - продвинуть на n позиций  
distance(it1, it2) - расстояние между двумя итераторами  
iter_swap(it1, it2) - переставляет не сами итераторы, а значения на которые они указывают  
next(it), prev(it) - получить след, пред итератор


### Инвалидация итераторов 
[https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers)


### Многопоток
```cpp
void doWork(int& res) {} 
std::thread t(doWork, std::ref(k)); //используем ref семантику, иначе будет только копия, нужно для возврата результатов из функции
t.join(); //ждем выполнения потока в текущем потоке 
t.detach(); //отрываем объект от текущего потока
```

```cpp
int doWork() {} 
std::future<int> f = std::async(doWork); 
int res = f.get(); 
//либо со страгеиями выполнения - асинхронно или отложенно, по умолчанию смешанная стратегия 
auto f = std::async(std::launch::async);
```

### Conditional variable
Примитив синхронизации, позволяющий реагировать одному потоку на событие произошедшее в другом. Например, вместо бесконечного цикла, захватывающего и отпускающего мютекс на очередь, чтобы ее прочитать, создадим conditional_variable, который будет реагировать на непустую очередь, а в другом потоке будет с помощью notify_one(), notify_all() сообщать и записи в очередь. В первом потоке, если наше условие еще не выполнено, мы будем отпускать мютекс и уходить в сон, периодически будем просыпаться, брать мютекс и проверять условие.  

```cpp
#include "bits/stdc++.h"  
  
std::queue<int> q;  
std::mutex m;  
std::vector<int> v = {1,2,3,4,5,6,7,8,9};  
std::condition_variable cv;  
  
void write_queue() {  
	std::unique_lock lock(m);  
	for (int i : v) q.push(i);  
	cv.notify_one();  
}  

int main() {  
	std::thread t1(write_queue);  
	std::unique_lock lock(m);  
	while (q.empty()) cv.wait(lock);  
	
	while (!q.empty()) {  
		std::cout << q.front();  
		q.pop();  
	}  
  
	t1.join();  
	return 0;  
}
```

### Умные указатели
**std::unique_ptr** - ресурсом владеет только один экземпляр, удален конструктор и оператор копирования, можно только перемещать.

**std::shared_ptr** - ресурсом владеют несколько экземпляров, ref_count - счетчик ссылок, инкрементируется при копировании или присваении, декрементр при удалении объекта, если после декремента счетчик равен нулю, деструктор освобождает ресурс.

**std::weak_ptr** - невладеющий указатель, не увеличивает счетчик ссылок. Позволяет проверить, не удалился ли объект. Можно использовать, чтобы разорвать циклическую зависимость между shared_ptr.

expired - проверить, не удален ли объект на который ссылается weak_ptr - может быть гонка, поэтому используем lock  
lock - создать shared_ptr от ссылаемого объекта, по сути эквивалентен 
```cpp
return expired() ? shared_ptr<T>() : shared_ptr<T>(*this)
```
, но атомарно, т.к. с блокировкой  
use_count - возвращает количество shared_ptr которые управляются объектом

### Функциональный объект
Объект с переопределенным оператором круглые скобки

```cpp
template<class T>
struct less {
	bool operator()(const T& a, const T& b) {
		return a < b;
	}
}
```

### Лямбда-функции (анонимные)
```cpp
int x, y;
auto f = [](int a, int b) { return a < b; };
[x, &y] //захватить х по копии, y по ссылке
[&] //все по ссылке
[=] //все по копии
[=, &y] //все копии, но y по ссылке
```
В [] - пишем переменные, которые хотим захватить для дальнейшего использования в функции, можем захватывать по копии или ссылке.

```cpp
auto f = [](int a, int b) -> bool { return a < b; }; //можно указывать возврат знач.

auto bar = []<class T>(const T& a, const T& b) { return a < b; }; //поддерживают шаблоны

std::vector<int> v{1, 4, 3, 2};
std::ranges::sort(v, [](const auto& a, const auto& b) { return a < b; }); //auto аргументы лямбды - сахар над шаблонами

```

### Variadic templates
Позволяет передавать переменное количество аргументов для функции/класса

```cpp
template<class... Args> //переменное количесвто аргументов любого типа
void PrintAll(Args&&... args) { //универсальная ссылка
	Foo(args...) //Foo(a, b, c)
	Foo(g(args)...) //Foo(g(a), g(b), g(c))
	Foo(std::forward(args)...) //Foo(std::forward(a), std::forward(b), ...)
}
```

**Pack expansion** - в зависимости от того, где находится троеточие, раскрывается по-разному.